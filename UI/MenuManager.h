#pragma once

#include <functional>
#include <juce_gui_basics/juce_gui_basics.h>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

namespace jucyaudio
{
    namespace ui
    {
        // A pure data struct for a single menu item, representing its logical state.
        struct MenuItem
        {
            std::string name;
            std::string description{};
            std::function<void()> action{};

            struct KeyPress
            {
                char key;
                juce::ModifierKeys mods;
            };
            std::optional<KeyPress> keyPress{};

            // For radio button groups
            bool isRadioButton{false};
            std::function<bool()> isTicked{}; // Callback to check if it should be ticked
            int commandId{0}; // Internal ID generated by the manager
        };

        // A pure data struct for a top-level menu or a submenu.
        struct Menu
        {
            std::string name;
            std::vector<MenuItem> items;
            std::vector<Menu> subMenus; // For nested submenus
        };

        // A pure C++ class that holds the logical structure of the application's menus.
        // It knows nothing about JUCE Components or event handling.
        class MenuManager final
        {
        public:
            MenuManager() = default;

            // The primary API for defining the menu structure.
            void registerMenu(const std::string &menuName, std::vector<MenuItem> items);

            // API for adding a submenu to an existing menu.
            void addSubMenu(const std::string &parentMenuName, const std::string &subMenuName, std::vector<MenuItem> items);

            const std::vector<Menu> &getMenus() const
            {
                return m_menus;
            }
            const std::unordered_map<int, MenuItem> &getCommandMap() const
            {
                return m_commandMap;
            }

        private:
            int getNextCommandId()
            {
                return m_nextCommandId++;
            }
            Menu *findMenu(const std::string &menuName, std::vector<Menu> &menus);

            std::vector<Menu> m_menus;
            std::unordered_map<int, MenuItem> m_commandMap; // Maps generated ID to the item
            int m_nextCommandId = 1;                        // Our own sequential ID generator
        };
    } // namespace ui
} // namespace jucyaudio